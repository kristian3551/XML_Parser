# **XML_Parser**

Това е вторият проект за курса Обектно-ориентирано програмиране 1-ви курс 2-ри семестър 2022 г., спец. Компютърни науки. Целта на проекта е да се създаде конзолно приложение за работа с XML файлове. Потребителят има възможността да отваря файлове, да редактира, изтрива, добавя XML елементи към файл и да търси XML елементи по определени критерии. Линк към GitHub: [https://github.com/kristian3551/XML_Parser](https://github.com/kristian3551/XML_Parser)

## Цел и задачи за разработка

Основната цел на проекта е да се създаде удобна и гъвкава структура от данни, която репрезентира един XML документ, както и гъвкава ООП структура, която може да бъде развивана и занапред. 
*Разработени функционалности*
1. Отваряне на файлове през конзолен интерфейс
2. Стандартни операции за запазване на файлове.
3. Извеждане на възможните интерфейсни команди за потребителя.
4. Принтиране на файлове.
5. Извеждане на стойност на атрибут на даден XML елемент.
6. Редактиране, добавяне и изтриване на атрибут на елемент във файл по подадено ID, тип атрибут и стойност.
7. Функционалност за търсене на елементи в XML файл посредством XPath стрингове и имплементирани функции.
8. Промяна на текстовото съдържание на XML елемент.
9. Добавяне на елемент като дете на XML елемент по подадено ID.
10. Изтриване на елемент.

## Съдържание
>1. [Цел и задачи за разработка](#цел-и-задачи-за-разработка)
>2. [Преглед на предметната област](#преглед-на-предметната-област)
>3. [Проектиране](#проектиране)
>4. [Важни елементи на реализацията. Тестване](#важни-елементи-на-реализацията-тестване)
>5. [Бъдещи подобрения, ресурси](#бъдещи-подобрения)
## Преглед на предметната област

**XML файлът** представлява дървовидна структура от XML елементи, като всеки XML елемент има други елементи в неговия обсег. Затова линейна структура от данни както например `std::vector` не е най-удачната. Основна задача на проекта е измислянето на ефективно четене от файл и пресъздаването му в паметта. От друга страна, за един XML editor се изисква той да бъде лесно достъпен т.е. да има един добре направен интерфейс, който да прилича до някаква степен на стандартен интерфейс за четене и писане на файлове (Microsoft Word, Notepad, etc.).  

**Откъм алгоритмична гледна точка** проектът изисква бързи и ефективни алгоритми. Основна структура от данни в проекта е *дърво*, реализирано в класа `XmlElement`. Търсенето между елементи в дървото е със сложност О(n), което с линейна структура от данни много трудно би се достигнало. Алгоритъмът за парсване е рекурсивен. Всички алгоритми в проекта не надвишават линейна сложност.  

Класът `Dictionary`, който е използван за пазене на атрибутите на XML елементите представлява чисто и просто динамичен масив от чифтове, а всичкото търсене е линейно спрямо броя атрибути. Възможна оптимизация за в бъдеще е да се реализира хеширащ алгоритъм, за да можем да търсим атрибути в колекцията с константна сложност, но програмистът, пишещ проекта, няма необходимият опит за това. Линейно търсене реализират всички останали помощни класове като `ArrayList` и `String`. 

Една оптимизация откъм програмистка гледна точка и гъвкавост на кода е полето *ids* в класа `XmlTree`, което при добавяне на елемент в дървото се добавя и референция към същия елемент за улеснено търсене и опростяване откъм алгоритми. 

## Проектиране

Кодът е изграден според *принципите на обектно-ориентираното програмиране*, изучавани до момента - абстракция и капсулация. Логиката на приложението не налага нуждата да се ползва наследяване или полимофорфизъм, поне на този начален етап на разработка.  

*Атомарни класове* в проекта са:
1. `ArrayList` - темплейтен клас, реализиращ динамичен масив. 
2. `String` - стандартен String клас (реализиран е буфер за оптимизиране на конкатенацията. Особено важно е за парсването в класа `XmlParser`).
3. `Dictionary` - темплейтен вектор от чифтове от ключове и стойности.

**XmlElement**

Класът реализира дървовидната структура, присъща за XML. Има полета за тип на тага, ID, текст (не е задължителен), динамичен масив от деца и списък от атрибути. Реализирани са всички функции за манипулиране на елемента (управление на децата, стандартни гетъри и сетъри на атрибути, ID, тип и т.н.). Реализирана е и функцията *freeElement*, която е приятелска и служи за изтриване на дърво (даден XML елемент, както и неговите наследници).
Реализирани са функции за връщане на списък от наследници, които отговарят на дадени условия (име на таг, текстово съдържание и др.).

**XmlTree**

Класът представлява контролер клас, който съдържа функциите, изисквани по условие. Тези функции извикват други функции върху елементи от дървото, реализирано с полето *root*. Съдържа също и функциите *getElementById(const String& id)*, които търсят наследник на *root* по дървото и извикват функции на тях. Полето *root* винаги се сетва с дифолтен корен, чиито деца и наследници са елементите на дървото, което създаваме с парсване от файл. Има две такива функции - една константна и една неконстантна - извиквани съответно в константни и неконстантни функции. 

**XmlParser**

Класът съдържа логика за четене от файл и построяване на дърво по информацията от файла посредством функцията *parseTree(XmlTree&)*. Обект от класа XmlParser съдържа поле *filePath*, което се пази с цел проверка дали е отворен файл и зареден във *fileContent*. 

**XmlPath**

Класът представлява неймспейс и съдържа единствена функция *getElements(const String& xmlPath, const XmlTree& tree)*, която по подадените параметри връща списък с всичките елементи в *tree*, които отговарят на описанието на дадения *xml path*. Класът е направен, за да се доразвива за в бъдеще с усложняване на логиката на тези query-та и добавяне на още функционалности. 

**Engine**

Класът реализира конзолния интерфейс на приложението. Съдържа единствена интерфейсна функция *run()*, която стартира приложението. Функциите, вътрешни за класа, са изискваните по условие функции. 

## Важни елементи на реализацията. Тестване

### String

`ArrayList<String> split(const String&) const`: връща списък с подстринговете на даден стринг, разделени от сепаратор. Пример: String("Programming is cool").split(" ") връща вектор с елементи "Programming", "is" и "cool". Забележка: **функцията не връща празен подстринг**.  
`String substring(int startIndex, int endIndex = -1) const`: връща подниза от стартовия индекс до крайния невкл. Ако не е подаден краен индекс, крайния индекс е дължината на стринга. Ако startIndex > endIndex, функцията хвърля *String*.  
*Останалите функции са стандартни за класа String (и същите, както в миналия проект)*

### XmlElement

`addChild(const XmlElement& el)`: динамично в паметта създава нов *XmlELement* копие на *el* и го добавя към децата на елемента, на който е извикана функцията.  
`ArrayList<const XmlElement*> XmlElement::getDescendants(const XmlElement* current) const`: рекурсивна функция, която връща списък с всичките наследници на елемента.  
`void saveInFile(std::ostream& os, int k = 0) const`: запазва информация в правилен формат във файл. Разликата между saveInFile и print функциите е, че saveInFile не записва автоматично генерираното id, докато print го принтира.  
`friend void freeElement(XmlElement*)`: изтрива рекурсивно динамично заделените наследници на даден *XmlElement*, както и самия него.
`ArrayList<XmlElement*> getChildren()` и `ArrayList<const XmlElement*> getChildren() const`: функции, връщащи децата на даден елемент. Едната се използва от неконстантни референции/пойнтъри, докато другата се използва от константни такива. Мотивацията е, че 
в някои ситуации има логика едно дете да се променя през родителя. Това се използва в DOM
функционалностите на браузъра например. Подобрява гъвкавостта на кода също така.  

### XmlTree

*За целите на този проект дървото не трябва да се копира и затова копи конструкторът е забранен, както и операторът равно.*  
`XmlTree()`: създава дефолтен корен на дървото.
`void saveInFile(const String& filePath) const`: записва във файл рекурсивно всички деца и наследници на корена, които всъщност са елементите на дървото, от които се интересуваме.  
*Почти всички функции извикват функциите за търсене в дърво и функции, дефинирани за XmlElement обект. На практика класът представлява контролер за функционалностите, изисквани по условие. Също така класовете XmlElement и XmlTree могат да бъдат съединени в едно, но XmlTree е едно ниво по-високо.*  
*В класа има функции, които връщат списъци от константни елементи. Те използват данните от полето ids, което е речник с ID-та и пойнтъри към елементите в дървото. Това допълнение помага за достъпа до елементи, защото го опростява и не налага използването на алгоритми като BFS и DFS, които не са и наложителни поне на този етап.*  

### XmlParser

`void parse(const String& elementTextContent, XmlTree& tree, const XmlElement* parent, int& iter) const`:
 това е функцията, която на практика свързва даден XML файл с паметта. *elementTextContent* се чете с броята *iter*, който трябва да е независим от стековата рамка на функцията. Последователно четем данните на елементите, създаваме *XmlElement* обекти и ги добавяме в дървото като деца на съответния *parent*. Преди да се чете файлът, той се запазва във *fileContent*, който се минимизира (премахват се табове, редъндант спейсове и нови редове) във функцията `void XmlParser::minify();`. Рекурсивната логика е следната:  
 1. Четем отварящ таг '<'. Прескачаме го. Докато не стигнем до '>', четем информацията на тага. Създаваме обект от тип *XmlElement*.  
 2. Докато не срещнем '<', четем текстовото съдържание на тага и накрая го добавяме към създадения обект.  
 3. Ако следващия символ е '\', то дочитаме до затварящия символ '>'. Отиваме на 4. В противен случай четем следващия таг (рекурсивно извикване).  
 4. Ако следващия елемент е '<', то гледаме дали елементът е '\'. Ако е, функцията приключва. В противен случай четем следващия таг (рекурсивно извикване).  
*Във функцията има базова валидация, но в общия случай се приема, че файлът е коректен.*  
*Класът пази информация за файла, от който е заредено съдържанието. Това се ползва в Engine за проверка дали е отворен файл или не.*  

### XmlPath
`ArrayList<const XmlElement*> XmlPath::getElements(const String& xmlPath, const XmlTree& tree)`: функцията прави базов парсинг на *XPath* стринг посредством *String::split(const String& separator)*. Функцията е написана грубо. Развитие на *XPath* функционалностите е оставена за бъдещи подобрения. Логиката в общи линии е следната: разделяме стринга на части, разделяни от символа '\'. Разглеждат се случаи спрямо крайния символ (стандартна или квадратна скоба). 

### Engine
`void run()`: цикълът се управлява от променливата *input*. Въведеният стринг се разделя по спейсове и се извиква правилната функция спрямо първата въведена дума. Ако се хвърли грешкa *int*, то значи се иска дума, която не е въведена от потребителя. Функцията хваща такава грешка. Вътре във всички вътрешни за класа функции има *try* *catch* блокове.  

## Тестване

Функционалността е тествана ръчно. 

## Бъдещи подобрения
Възможни бъдещи подобрения са посочени в предишните параграфи. Те са в насока подобряване на валидацията на файлове и повече *XPath* функционалности.

### Ресурси
Проектът е направен без използване на външни ресурси. Специални благодарности на Камен Младенов за идеите за парсинга.

